# 6.6. Troubleshooting

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

**Ответ**

### Шаг 1. Остановка запроса пользователя

* Заходим в `mongos`
* Узнаём идентификатор `operationId` запроса с помощью [команды](https://docs.mongodb.com/manual/reference/method/db.currentOp/#active-operations-on-a-specific-database)
`db.currentOp({"secs_running":{$gte:180}})` (фильтр, что операция выполняется более 180 сек)
* Прерываем операцию с помощью [команды](https://docs.mongodb.com/manual/reference/method/db.killOp/#mongodb-method-db.killOp) `db.killOp(<operationId>)`. 
Так можно сделать, поскольку это пользовательская CRUD операция. С системными операциями БД и построением индексов так делать не надо.
* Разбираем запрос разработчика, возможно он написан нехорошо.

### Шаг 2. Разбираемся с долгими запросами

* Включаем профилировщик медленных запросов (порог 100мс) `db.setProfilingLevel(1, 100)`
* Регулярно просматриваем самые тяжелые операции `db.system.profile.find( { millis : { $gt : 100 } } )` (дольше 100 мс)
* С помощью `explain` разбираем частые проблемные запросы: переписываем их, добавляем или удаляем индексы


## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

**Ответ**

### Шаг 1. Поиск решения проблемы

Я думаю, что из роста числа реплик и дополнительных задержек, связанных с реплицированием и сетевым взаимодействием, Redis перестал успевать обрабатывать истекающие ключи (которые появились из-за режима TTL), а когда их количество превысило 25% - появились блокировки записи, см. документацию [Latency generated by expires](https://redis.io/topics/latency#latency-generated-by-expires).

Предложения - уменьшить количество реплик или выделить более мощный сервер.

## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

**Ответ**

### Шаг 1. Поиск решения проблемы

Согласно разделу документации [B.3.2.3 Lost connection to MySQL server](https://dev.mysql.com/doc/refman/8.0/en/error-lost-connection.html)

* *Проверка сетевого взаимодействия*. Возможно данных слишком много и СУБД не успевает вернуть большое количество записей. Чтобы в этом убедиться, следует увеличить значение параметра `net_read_timeout` в 2 раза (по умолчанию значение 30 сек).
* *Начальное соединение*. В более редких случаях это может быть проблемой подключения к серверу. Чтобы проверить стоит увеличить `connect_timeout` до десятков секунд.
* *Проверка размера пакета*. В случае BLOB данных может помочь увеличение параметра `max_allowed_packet`.

## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

**Ответ**

### Шаг 1. Поиск решения проблемы

Скорее всего не осталось свободной памяти. В этом случае Linux убирает сторонние процессы, чтобы самому продолжить работать.

Предложения:
* Добавить памяти (её много не бывает :))
* Проверить конфигурацию / ограничить потребление ресурсов, см. в документации [19.4. Потребление ресурсов](https://postgrespro.ru/docs/postgresql/12/runtime-config-resource)
* Настройки на сервере - можно почитать в статье [Настраиваем Out-Of-Memory Killer в Linux для PostgreSQL](https://habr.com/ru/company/southbridge/blog/464245/)
